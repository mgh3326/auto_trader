#!/usr/bin/env python3
"""
ÏóÖÎπÑÌä∏ ÏΩîÏù∏ ÏûêÎèô Îß§Ïàò Ï£ºÎ¨∏ ÏãúÏä§ÌÖú
"""

import asyncio
import decimal
from typing import List, Dict, Optional
from app.analysis.service_analyzers import UpbitAnalyzer
from app.services import upbit
from app.services.stock_info_service import get_coin_sell_price, get_coin_sell_price_range
from data.coins_info import upbit_pairs



async def process_buy_orders_for_my_coins():
    """Î≥¥Ïú† ÏΩîÏù∏Ïóê ÎåÄÌï¥ Îß§Ïàò Ï£ºÎ¨∏ ÌîÑÎ°úÏÑ∏Ïä§Î•º Ïã§ÌñâÌï©ÎãàÎã§."""
    
    # Upbit ÏÉÅÏàò Ï¥àÍ∏∞Ìôî
    await upbit_pairs.prime_upbit_constants()
    
    # JSON Î∂ÑÏÑùÍ∏∞ Ï¥àÍ∏∞Ìôî
    analyzer = UpbitAnalyzer()
    
    try:
        # 1. Î≥¥Ïú† ÏΩîÏù∏ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
        print("=== Î≥¥Ïú† ÏΩîÏù∏ Ï°∞Ìöå ===")
        my_coins = await upbit.fetch_my_coins()
        print(f"Ï¥ù {len(my_coins)}Í∞ú ÏûêÏÇ∞ Î≥¥Ïú† Ï§ë")
        
        # 2. Í±∞Îûò Í∞ÄÎä•Ìïú ÏΩîÏù∏Îßå ÌïÑÌÑ∞ÎßÅ (ÏõêÌôî Ï†úÏô∏, ÏµúÏÜå ÌèâÍ∞ÄÏï° Ïù¥ÏÉÅ, KRW ÎßàÏºì Í±∞Îûò Í∞ÄÎä•)
        tradable_coins = [
            coin for coin in my_coins
            if coin.get("currency") != "KRW"  # ÏõêÌôî Ï†úÏô∏
               and analyzer._is_tradable(coin)  # ÏµúÏÜå ÌèâÍ∞ÄÏï° Ïù¥ÏÉÅ
               and coin.get("currency") in upbit_pairs.KRW_TRADABLE_COINS  # KRW ÎßàÏºìÏóêÏÑú Í±∞Îûò Í∞ÄÎä•
        ]

        # 3. ÏΩîÏù∏ÏùÑ Î≥¥Ïú† Í∏àÏï° Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨ (ÌÅ∞ ÏàúÏÑúÎåÄÎ°ú)
        # def calculate_total_value(coin):
        #     balance = float(coin.get('balance', 0))
        #     locked = float(coin.get('locked', 0))
        #     avg_buy_price = float(coin.get('avg_buy_price', 0))
        #     return (balance + locked) * avg_buy_price
        #
        # tradable_coins.sort(key=calculate_total_value, reverse=True)

        # Î™®Îì† ÏΩîÏù∏Ïùò ÌòÑÏû¨Í∞ÄÎ•º Ìïú Î≤àÏóê Ï°∞ÌöåÌïòÏó¨ ÏàòÏùµÎ•† Í≥ÑÏÇ∞
        if tradable_coins:
            # ÎßàÏºì ÏΩîÎìú Î¶¨Ïä§Ìä∏ ÏÉùÏÑ±
            market_codes = [f"KRW-{coin['currency']}" for coin in tradable_coins]
            
            try:
                print(f"üìä {len(market_codes)}Í∞ú ÏΩîÏù∏Ïùò ÌòÑÏû¨Í∞Ä ÏùºÍ¥Ñ Ï°∞Ìöå Ï§ë...")
                
                # ÏóÖÎπÑÌä∏ Í≥µÌÜµ Ìï®Ïàò ÏÇ¨Ïö©ÌïòÏó¨ ÌòÑÏû¨Í∞Ä ÏùºÍ¥Ñ Ï°∞Ìöå
                current_prices = await upbit.fetch_multiple_current_prices(market_codes)
                
                print(f"‚úÖ {len(current_prices)}Í∞ú ÏΩîÏù∏Ïùò ÌòÑÏû¨Í∞Ä Ï°∞Ìöå ÏôÑÎ£å")
                
                # Í∞Å ÏΩîÏù∏Ïùò ÏàòÏùµÎ•† Í≥ÑÏÇ∞
                for coin in tradable_coins:
                    avg_buy_price = float(coin.get('avg_buy_price', 0))
                    currency = coin['currency']
                    market = f"KRW-{currency}"
                    
                    if avg_buy_price > 0 and market in current_prices:
                        current_price = current_prices[market]
                        # ÏàòÏùµÎ•† Í≥ÑÏÇ∞: (ÌòÑÏû¨Í∞Ä - ÌèâÍ∑† Îã®Í∞Ä) / ÌèâÍ∑† Îã®Í∞Ä
                        profit_rate = (current_price - avg_buy_price) / avg_buy_price
                        coin['profit_rate'] = profit_rate
                    else:
                        # Îß§Ïàò ÎÇ¥Ïó≠Ïù¥ ÏóÜÍ±∞ÎÇò ÌòÑÏû¨Í∞Ä Ï°∞Ìöå Ïã§Ìå®Ìïú Í≤ΩÏö∞
                        coin['profit_rate'] = float('inf')
                
            except Exception as e:
                print(f"‚ùå ÌòÑÏû¨Í∞Ä ÏùºÍ¥Ñ Ï°∞Ìöå Ïã§Ìå®: {e}")
                # Ïã§Ìå® Ïãú Î™®Îì† ÏΩîÏù∏Ïóê Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
                for coin in tradable_coins:
                    coin['profit_rate'] = float('inf')

        # ÏàòÏùµÎ•†Ïù¥ Ï¢ãÏßÄ ÏïäÏùÄ Ïàú(Ïò§Î¶ÑÏ∞®Ïàú)ÏúºÎ°ú Ï†ïÎ†¨
        tradable_coins.sort(key=lambda c: c.get('profit_rate', float('inf')))

        print(f"Í±∞Îûò Í∞ÄÎä•Ìïú ÏΩîÏù∏: {len(tradable_coins)}Í∞ú (ÏàòÏùµÎ•† ÎÇÆÏùÄ Ïàú)")
        for coin in tradable_coins:
            balance = float(coin['balance'])
            locked = float(coin['locked'])
            avg_buy_price = float(coin['avg_buy_price'])
            total_value = (balance + locked) * avg_buy_price
            profit_rate = coin.get('profit_rate', float('inf'))
            
            if profit_rate == float('inf'):
                profit_str = "ÏàòÏùµÎ•† Í≥ÑÏÇ∞ Î∂àÍ∞Ä"
            else:
                profit_str = f"ÏàòÏùµÎ•†: {profit_rate:+.2%}"
            
            print(f"  - {coin['currency']}: {balance + locked:.8f} (Î≥¥Ïú† Í∏àÏï°: {total_value:,.0f}Ïõê, ÌèâÍ∑† Îã®Í∞Ä: {avg_buy_price:,.0f}Ïõê, {profit_str})")
        
        if not tradable_coins:
            print("Í±∞Îûò Í∞ÄÎä•Ìïú ÏΩîÏù∏Ïù¥ ÏóÜÏäµÎãàÎã§.")
            return
        
        # 4. Í∞Å ÏΩîÏù∏Ïóê ÎåÄÌï¥ Î∂ÑÌï† Îß§Ïàò Ï≤òÎ¶¨
        for coin in tradable_coins:
            await process_single_coin_buy_orders(coin, analyzer)
        
    except Exception as e:
        print(f"‚ùå ÏóêÎü¨ Î∞úÏÉù: {e}")
        import traceback
        traceback.print_exc()
    finally:
        await analyzer.close()


async def process_single_coin_buy_orders(coin: dict, analyzer: UpbitAnalyzer):
    """Îã®Ïùº ÏΩîÏù∏Ïóê ÎåÄÌïú Î∂ÑÌï† Îß§Ïàò Ï£ºÎ¨∏ÏùÑ Ï≤òÎ¶¨Ìï©ÎãàÎã§."""
    
    currency = coin['currency']
    market = f"KRW-{currency}"
    avg_buy_price = float(coin['avg_buy_price'])
    
    print(f"\n=== {currency} Î∂ÑÌï† Îß§Ïàò Ï≤òÎ¶¨ ÏãúÏûë ===")
    print(f"ÌòÑÏû¨ ÌèâÍ∑† Îã®Í∞Ä: {avg_buy_price:,.0f}Ïõê")
    
    try:
        # 1. ÌòÑÏû¨Í∞Ä Ï°∞Ìöå
        current_price_df = await upbit.fetch_price(market)
        current_price = float(current_price_df.iloc[0]['close'])
        
        print(f"ÌòÑÏû¨Í∞Ä: {current_price:,.0f}Ïõê")
        
        # 2. Í∏∞Ï°¥ Îß§Ïàò Ï£ºÎ¨∏ Î®ºÏ†Ä Ï∑®ÏÜå (Ï°∞Í±¥Í≥º ÏÉÅÍ¥ÄÏóÜÏù¥)
        await cancel_existing_buy_orders(market)
        
        # 3. Î∂ÑÏÑù Í≤∞Í≥º Í∏∞Î∞ò Ï°∞Í±¥ ÌôïÏù∏ Î∞è Îß§Ïàò Ï≤òÎ¶¨
        from app.services.stock_info_service import process_buy_orders_with_analysis
        
        await process_buy_orders_with_analysis(market, current_price, avg_buy_price)
        
    except Exception as e:
        print(f"‚ùå {currency} Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: {e}")
        import traceback
        traceback.print_exc()


async def cancel_existing_buy_orders(market: str):
    """Ìï¥Îãπ ÎßàÏºìÏùò Í∏∞Ï°¥ Îß§Ïàò Ï£ºÎ¨∏Îì§ÏùÑ Ï∑®ÏÜåÌï©ÎãàÎã§."""
    
    try:
        print(f"Í∏∞Ï°¥ {market} Îß§Ïàò Ï£ºÎ¨∏ Ï°∞Ìöå Ï§ë...")
        
        # Ìï¥Îãπ ÎßàÏºìÏùò Ï≤¥Í≤∞ ÎåÄÍ∏∞ Ï§ëÏù∏ Ï£ºÎ¨∏ Ï°∞Ìöå
        open_orders = await upbit.fetch_open_orders(market)
        
        # Îß§Ïàò Ï£ºÎ¨∏Îßå ÌïÑÌÑ∞ÎßÅ
        buy_orders = [
            order for order in open_orders 
            if order.get('side') == 'bid'  # Îß§Ïàò Ï£ºÎ¨∏
        ]
        
        if not buy_orders:
            print(f"  Ï∑®ÏÜåÌï† Îß§Ïàò Ï£ºÎ¨∏Ïù¥ ÏóÜÏäµÎãàÎã§.")
            return
        
        print(f"  {len(buy_orders)}Í∞ú Îß§Ïàò Ï£ºÎ¨∏ Î∞úÍ≤¨")
        for order in buy_orders:
            price = float(order.get('price', 0))
            volume = float(order.get('volume', 0))
            remaining = float(order.get('remaining_volume', 0))
            print(f"    - Í∞ÄÍ≤©: {price:,.0f}Ïõê, ÏàòÎüâ: {volume:.8f}, ÎØ∏Ï≤¥Í≤∞: {remaining:.8f}")
        
        # Ï£ºÎ¨∏ Ï∑®ÏÜå
        order_uuids = [order['uuid'] for order in buy_orders]
        cancel_results = await upbit.cancel_orders(order_uuids)
        
        success_count = sum(1 for result in cancel_results if 'error' not in result)
        print(f"  ‚úÖ {success_count}/{len(buy_orders)}Í∞ú Ï£ºÎ¨∏ Ï∑®ÏÜå ÏôÑÎ£å")
        
    except Exception as e:
        print(f"‚ùå Ï£ºÎ¨∏ Ï∑®ÏÜå Ï§ë Ïò§Î•ò: {e}")


# ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÎäî Ìï®ÏàòÎì§ Ï†úÍ±∞Îê® - stock_info_service.pyÎ°ú Ïù¥Îèô


async def place_split_buy_order_with_analysis(market: str, amount: int, current_price: float, buy_ranges: dict):
    """Î∂ÑÏÑù Í≤∞Í≥ºÏùò Îß§Ïàò Í∞ÄÍ≤© Î≤îÏúÑÎ•º ÌôúÏö©Ìïú Î∂ÑÌï† Îß§Ïàò Ï£ºÎ¨∏."""
    
    try:
        print(f"üí∞ {market} {amount:,}Ïõê Î∂ÑÏÑù Í∏∞Î∞ò ÏßÄÏ†ïÍ∞Ä Îß§Ïàò Ï£ºÎ¨∏")
        
        # 1. ÏµúÏ†Å Îß§Ïàò Í∞ÄÍ≤© Í≤∞Ï†ï
        order_price = determine_optimal_buy_price(current_price, buy_ranges)
        
        if order_price is None:
            print("  ‚ö†Ô∏è Î∂ÑÏÑù Í≤∞Í≥ºÏóê Îß§Ïàò Í∞ÄÍ≤© Î≤îÏúÑÍ∞Ä ÏóÜÏäµÎãàÎã§. ÌòÑÏû¨Í∞Ä Í∏∞Ï§ÄÏúºÎ°ú Ï£ºÎ¨∏Ìï©ÎãàÎã§.")
            order_price = current_price * 1.001  # ÌòÑÏû¨Í∞ÄÎ≥¥Îã§ 0.1% ÎÜíÍ≤å
        
        # 2. Îß§Ïàò ÏàòÎüâ Í≥ÑÏÇ∞ (ÏàòÏàòÎ£å Í≥†Î†§)
        fee_rate = 0.0005  # ÏóÖÎπÑÌä∏ ÏàòÏàòÎ£å 0.05%
        effective_amount = amount * (1 - fee_rate)
        volume = effective_amount / order_price
        
        print(f"  - Ï£ºÎ¨∏ Í∞ÄÍ≤©: {order_price:,.0f}Ïõê")
        print(f"  - Ï£ºÎ¨∏ ÏàòÎüâ: {volume:.8f}")
        
        # 3. ÏßÄÏ†ïÍ∞Ä Îß§Ïàò Ï£ºÎ¨∏
        order_result = await upbit.place_buy_order(
            market=market,
            price=str(int(order_price)),
            volume=str(volume),
            ord_type="limit"
        )
        
        print(f"  ‚úÖ Ï£ºÎ¨∏ ÏÑ±Í≥µ:")
        print(f"    - Ï£ºÎ¨∏ ID: {order_result.get('uuid')}")
        print(f"    - Îß§Ïàò Í∞ÄÍ≤©: {order_price:,.0f}Ïõê")
        print(f"    - Îß§Ïàò ÏàòÎüâ: {volume:.8f}")
        print(f"    - ÏòàÏÉÅ Í∏àÏï°: {int(order_price) * volume:,.0f}Ïõê")
        print(f"    - Ï£ºÎ¨∏ ÏãúÍ∞Ñ: {order_result.get('created_at')}")
        
        return order_result
        
    except Exception as e:
        print(f"‚ùå ÏßÄÏ†ïÍ∞Ä Ï£ºÎ¨∏ Ïã§Ìå®: {e}")
        print(f"   ÏãúÏû•Í∞Ä Îß§ÏàòÎ°ú ÎåÄÏ≤¥ ÏãúÎèÑ...")
        
        # ÏßÄÏ†ïÍ∞Ä Ï£ºÎ¨∏ Ïã§Ìå® Ïãú ÏãúÏû•Í∞ÄÎ°ú ÎåÄÏ≤¥
        try:
            order_result = await upbit.place_market_buy_order(market, str(amount))
            print(f"  ‚úÖ ÏãúÏû•Í∞Ä Ï£ºÎ¨∏ ÏÑ±Í≥µ:")
            print(f"    - Ï£ºÎ¨∏ ID: {order_result.get('uuid')}")
            print(f"    - Îß§Ïàò Í∏àÏï°: {amount:,}Ïõê")
            print(f"    - Ï£ºÎ¨∏ ÏãúÍ∞Ñ: {order_result.get('created_at')}")
            return order_result
        except Exception as e2:
            print(f"‚ùå ÏãúÏû•Í∞Ä Ï£ºÎ¨∏ÎèÑ Ïã§Ìå®: {e2}")
            return None


def determine_optimal_buy_price(current_price: float, buy_ranges: dict) -> float:
    """Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Î∞îÌÉïÏúºÎ°ú ÏµúÏ†Å Îß§Ïàò Í∞ÄÍ≤©ÏùÑ Í≤∞Ï†ïÌï©ÎãàÎã§."""
    
    appropriate_buy = buy_ranges.get('appropriate_buy')
    buy_hope = buy_ranges.get('buy_hope')
    
    print(f"  üìä Î∂ÑÏÑù Í≤∞Í≥º:")
    if appropriate_buy:
        print(f"    - Ï†ÅÏ†àÌïú Îß§Ïàò Î≤îÏúÑ: {appropriate_buy[0]:,.0f}Ïõê ~ {appropriate_buy[1]:,.0f}Ïõê")
    if buy_hope:
        print(f"    - Ìù¨Îßù Îß§Ïàò Î≤îÏúÑ: {buy_hope[0]:,.0f}Ïõê ~ {buy_hope[1]:,.0f}Ïõê")
    
    # Ï†ÑÎûµ 1: appropriate_buy Î≤îÏúÑÍ∞Ä ÏûàÏúºÎ©¥ Ïö∞ÏÑ† ÏÇ¨Ïö©
    if appropriate_buy:
        min_price, max_price = appropriate_buy
        
        # ÌòÑÏû¨Í∞ÄÍ∞Ä Ï†ÅÏ†àÌïú Îß§Ïàò Î≤îÏúÑ ÎÇ¥Ïóê ÏûàÏúºÎ©¥ ÌòÑÏû¨Í∞Ä ÏÇ¨Ïö©
        if min_price <= current_price <= max_price:
            order_price = current_price
            print(f"  üéØ Ï†ÑÎûµ: ÌòÑÏû¨Í∞ÄÍ∞Ä Ï†ÅÏ†àÌïú Îß§Ïàò Î≤îÏúÑ ÎÇ¥ ‚Üí ÌòÑÏû¨Í∞Ä ÏÇ¨Ïö© ({order_price:,.0f}Ïõê)")
            return order_price
        
        # ÌòÑÏû¨Í∞ÄÍ∞Ä Î≤îÏúÑÎ≥¥Îã§ ÎÇÆÏúºÎ©¥ ÏµúÎåÄÍ∞í ÏÇ¨Ïö© (Îçî ÎßéÏù¥ Îß§Ïàò)
        elif current_price < min_price:
            order_price = max_price
            print(f"  üéØ Ï†ÑÎûµ: ÌòÑÏû¨Í∞ÄÍ∞Ä Î≤îÏúÑÎ≥¥Îã§ ÎÇÆÏùå ‚Üí ÏµúÎåÄÍ∞í ÏÇ¨Ïö© ({order_price:,.0f}Ïõê)")
            return order_price
        
        # ÌòÑÏû¨Í∞ÄÍ∞Ä Î≤îÏúÑÎ≥¥Îã§ ÎÜíÏúºÎ©¥ ÏµúÏÜåÍ∞í ÏÇ¨Ïö© (Î≥¥ÏàòÏ†Å Îß§Ïàò)
        else:  # current_price > max_price
            order_price = min_price
            print(f"  üéØ Ï†ÑÎûµ: ÌòÑÏû¨Í∞ÄÍ∞Ä Î≤îÏúÑÎ≥¥Îã§ ÎÜíÏùå ‚Üí ÏµúÏÜåÍ∞í ÏÇ¨Ïö© ({order_price:,.0f}Ïõê)")
            return order_price
    
    # Ï†ÑÎûµ 2: appropriate_buyÍ∞Ä ÏóÜÏúºÎ©¥ buy_hope ÏÇ¨Ïö©
    elif buy_hope:
        min_price, max_price = buy_hope
        
        # Ìù¨Îßù Î≤îÏúÑÏùò Ï§ëÍ∞ÑÍ∞í ÏÇ¨Ïö©
        order_price = (min_price + max_price) / 2
        print(f"  üéØ Ï†ÑÎûµ: Ìù¨Îßù Îß§Ïàò Î≤îÏúÑÏùò Ï§ëÍ∞ÑÍ∞í ÏÇ¨Ïö© ({order_price:,.0f}Ïõê)")
        return order_price
    
    # Ï†ÑÎûµ 3: Î∂ÑÏÑù Í≤∞Í≥ºÍ∞Ä ÏóÜÏúºÎ©¥ None Î∞òÌôò (ÌòÑÏû¨Í∞Ä Í∏∞Ï§ÄÏúºÎ°ú Ï≤òÎ¶¨)
    else:
        print(f"  üéØ Ï†ÑÎûµ: Î∂ÑÏÑù Í≤∞Í≥º ÏóÜÏùå ‚Üí ÌòÑÏû¨Í∞Ä Í∏∞Ï§ÄÏúºÎ°ú Ï≤òÎ¶¨")
        return None


# Í∏∞Ï°¥ Ìï®ÏàòÎäî Î∞±ÏóÖÏö©ÏúºÎ°ú Ïú†ÏßÄ
async def place_split_buy_order(market: str, amount: int, current_price: float):
    """Í∏∞Î≥∏ Î∂ÑÌï† Îß§Ïàò Ï£ºÎ¨∏ (Î∞±ÏóÖÏö©)."""
    
    try:
        order_price = current_price * 1.001  # ÌòÑÏû¨Í∞ÄÎ≥¥Îã§ 0.1% ÎÜíÏùÄ Í∞ÄÍ≤©
        
        fee_rate = 0.0005
        effective_amount = amount * (1 - fee_rate)
        volume = effective_amount / order_price
        
        print(f"üí∞ {market} {amount:,}Ïõê Í∏∞Î≥∏ ÏßÄÏ†ïÍ∞Ä Îß§Ïàò Ï£ºÎ¨∏")
        print(f"  - Ï£ºÎ¨∏ Í∞ÄÍ≤©: {order_price:,.0f}Ïõê (ÌòÑÏû¨Í∞ÄÏùò 100.1%)")
        print(f"  - Ï£ºÎ¨∏ ÏàòÎüâ: {volume:.8f}")
        
        order_result = await upbit.place_buy_order(
            market=market,
            price=str(int(order_price)),
            volume=str(volume),
            ord_type="limit"
        )
        
        print(f"  ‚úÖ Ï£ºÎ¨∏ ÏÑ±Í≥µ:")
        print(f"    - Ï£ºÎ¨∏ ID: {order_result.get('uuid')}")
        print(f"    - Îß§Ïàò Í∞ÄÍ≤©: {order_price:,.0f}Ïõê")
        print(f"    - Îß§Ïàò ÏàòÎüâ: {volume:.8f}")
        print(f"    - ÏòàÏÉÅ Í∏àÏï°: {int(order_price) * volume:,.0f}Ïõê")
        print(f"    - Ï£ºÎ¨∏ ÏãúÍ∞Ñ: {order_result.get('created_at')}")
        
        return order_result
        
    except Exception as e:
        print(f"‚ùå Îß§Ïàò Ï£ºÎ¨∏ Ïã§Ìå®: {e}")
        return None


async def main():
    """Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò"""
    print("üöÄ ÏóÖÎπÑÌä∏ ÏûêÎèô Îß§Ïàò Ï£ºÎ¨∏ ÏãúÏä§ÌÖú ÏãúÏûë")
    print("=" * 50)
    
    # ÌôòÍ≤Ω Î≥ÄÏàò ÌôïÏù∏
    from app.core.config import settings
    if not settings.upbit_access_key or not settings.upbit_secret_key:
        print("‚ùå ÏóÖÎπÑÌä∏ API ÌÇ§Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
        print("   UPBIT_ACCESS_KEYÏôÄ UPBIT_SECRET_KEY ÌôòÍ≤Ω Î≥ÄÏàòÎ•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.")
        return
    
    print(f"‚úÖ API ÌÇ§ ÌôïÏù∏: Access Key {settings.upbit_access_key[:8]}...")

    await process_buy_orders_for_my_coins()
    
    print("\n" + "=" * 50)
    print("üèÅ Îß§Ïàò Ï£ºÎ¨∏ ÌîÑÎ°úÏÑ∏Ïä§ ÏôÑÎ£å")


if __name__ == "__main__":
    asyncio.run(main())
